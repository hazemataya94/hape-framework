# HAPE Framework: Overview & Vision

## What is HAPE Framework?
HAPE Framework is a lightweight and extensible Python framework designed to help platform engineers build customized CLI and API-driven platforms with minimal effort. It provides a structured way to develop orchestrators for managing infrastructure, CI/CD pipelines, cloud resources, and other platform engineering needs. 

HAPE is built around abstraction and automation, allowing engineers to define and manage resources like AWS, Kubernetes, GitHub, GitLab, ArgoCD, Prometheus, Grafana, HashiCorp Vault, and many others in a unified manner. It eliminates the need to manually integrate multiple packages for each tool, offering a streamlined way to build self-service developer portals and engineering platforms. 

## Where It All Started
Modern organizations manage hundreds of microservices, each with its own infrastructure, CI/CD, monitoring, and deployment configurations. This complexity increases the cognitive load on developers and slows down platform operations. 

HAPE Framework aims to reduce this complexity by enabling platform engineers to build opinionated, yet flexible automation tools that simplify onboarding, deployment, and operations. 

With HAPE, developers can interact with a CLI or API to create, deploy, and manage their services without diving into complex configurations. The framework also supports custom workflows, state management via databases, and integration with existing DevOps tools. 

## Core Principles
- **Abstraction & Modularity** – Developers work with high-level constructs rather than low-level implement- ation details. 
- **CLI & API Driven** – HAPE enables both CLI and API-based interactions, making it ideal for automation. 
- **Extensibility** – Supports custom workflows, integrations, and automation logic.
- **Minimal Cognitive Load** – Aims to provide intuitive commands and automation, so platform engineers don’t need to reinvent the wheel.
- **Infrastructure & CI/CD Agnostic** – Can be adapted to any cloud provider, DevOps stack, or orchestration tool.
- **State Management via Database** – Unlike static configuration-based tools, HAPE tracks states dynamically using a database.

## Key Features
- Automated CRUD generation for platform services (e.g., hape crud --create ServiceName {...}).
- Built-in CLI framework that can be extended for various platform engineering use cases.
- Pre-built integrations with cloud providers and DevOps tools.
- Simplified orchestration of deployments, CI/CD, monitoring, and permissions.
- Database-backed state tracking for workflows and configurations.
- Python-based, for efficiency and language simplicity.
- Supports automation beyond platform engineering, making it useful for multiple domains.

## Vision for the Future
HAPE Framework aims to become the go-to tool for building Internal Developer Platforms (IDPs) and self-service DevOps automation. It envisions a future where platform engineers can quickly spin up customizable automation platforms without needing to start from scratch.

The framework enables users to build fully managed solutions for CI/CD, infrastructure provisioning, developer access, cost monitoring, and more. The long-term goal is to foster open-source community contributions to extend integrations and functionality.

### Automated Workflow Execution

To create Create/READ/UPDATE/DELETE (CRUD) for a model deployment-cost to process cost for Kubernetes deployment, all you need is to run:
```
$ hape crud --create deployment-cost """
{
    "id": ["int","autoincrement"],
    "service-name": ["string"],
    "pod-cpu": ["string"],
    "pod-ram": ["string"],
    "autoscaling": ["bool"],
    "min-replicas": ["int",""],
    "max-replicas": ["int",""],
    "current-replicas": ["int"],
    "pod-cost": ["string"],
    "number-of-pods": ["int"],
    "total-cost": ["float"],
    "cost-unit": ["string"]
}
"""
```

Once the autogenerated files are created, you'll be able to run:
```
$ myawesomeplatform deployment-cost --help

usage: myawesomeplatform deployment-cost [-h] {save,get,get-all,delete,delete-all} ...

positional arguments:
  {save,get,get-all,delete,delete-all}
    save                Save DeploymentCost object based on passed arguments or filters
    get                 Get DeploymentCost object based on passed arguments or filters
    get-all             Get-all DeploymentCost objects based on passed arguments or filters
    delete              Delete DeploymentCost object based on passed arguments or filters
    delete-all          Delete-all DeploymentCost objects based on passed arguments or filters

options:
  -h, --help            show this help message and exit
```

and run:
```
$ myawesomeplatform deployment-cost save --help

usage: myawesomeplatform deployment-cost save [-h] [--id ID] [--created-at CREATED_AT] [--service-name SERVICE_NAME] [--pod-cpu POD_CPU]
                                    [--pod-ram POD_RAM] [--autoscaling AUTOSCALING] [--min-replicas MIN_REPLICAS] [--max-replicas MAX_REPLICAS]
                                    [--current-replicas CURRENT_REPLICAS] [--pod-cost POD_COST] [--number-of-pods NUMBER_OF_PODS]
                                    [--total-cost TOTAL_COST] [--cost-unit COST_UNIT]

options:
  -h, --help            show this help message and exit
  --id ID               Value for id type int
  --created-at CREATED_AT
                        Value for created-at type str
  --service-name SERVICE_NAME
                        Value for service-name type str
  --pod-cpu POD_CPU     Value for pod-cpu type str
  --pod-ram POD_RAM     Value for pod-ram type str
  --autoscaling AUTOSCALING
                        Value for autoscaling type <lambda>
  --min-replicas MIN_REPLICAS
                        Value for min-replicas type int
  --max-replicas MAX_REPLICAS
                        Value for max-replicas type int
  --current-replicas CURRENT_REPLICAS
                        Value for current-replicas type int
  --pod-cost POD_COST   Value for pod-cost type float
  --number-of-pods NUMBER_OF_PODS
                        Value for number-of-pods type int
  --total-cost TOTAL_COST
                        Value for total-cost type float
  --cost-unit COST_UNIT
                        Value for cost-unit type str
```

This level of automation makes HAPE a powerful framework for platform engineers to manage infrastructure, CI/CD, and service deployments with ease.

### How It Will Be Used
HAPE enables developers to quickly initialize and structure their platform projects with minimal setup. They install HAPE Framework via PyPI and initialize a new project effortlessly:
```
$ pip install hape-framework
$ hape init --name myawesomeplatform
```

This initializes a well-structured project with predefined directories:
```
myawesomeplatform/
│── dockerfiles/  (Copied from HAPE Framework)
│── Makefile      (Copied from HAPE Framework)
│── src/
│   ├── migrations/
│   ├── models/
│   ├── controllers/
│   ├── services/
│   ├── utils/
│   ├── config/
│   ├── tests/
│── docs/
│── scripts/
│── setup.py
│── README.md
```


### CRUD Creation
To create a CRUD functionality for a model:
```
hape crud --create MyModel '{"id": ["int", "autoincrement"], "value": ["string", "nullable"]}'
```

This generates the following files
- **Model**
```
from hape.base.model import Model
from sqlalchemy import Column, String

class MyModel(Model):
    __tablename__ = "mymodel"
    id = Column(Integer, primary_key=True, autoincrement=True)
    value = Column(String(255), nullable=False)

    def __init__(self, **kwargs):
        filtered_kwargs = {key: kwargs[key] for key in self.__table__.columns.keys() if key in kwargs}
        super().__init__(**filtered_kwargs)
        for key, value in filtered_kwargs.items():
            setattr(self, key, value)
```

- **Controller**
```
from hape.base.model_controller import ModelController
from myawesomeplatform.src.models.mymodel import MyModel

class MyModelController(ModelController):
    model = MyModel
```

- **View (CLI/Argument Parser)**
```
from hape.base.model_argument_parser import ModelArgumentParser
from myawesomeplatform.src.models.mymodel import MyModel
from myawesomeplatform.src.controllers.mymodel_controller import MyModelController

class MyModelArgumentParser(ModelArgumentParser):
    def __init__(self):
        super().__init__(MyModel, MyModelController)
```

- **Migration File**
```
from alembic import op
import sqlalchemy as sa

revision = '001_mymodel_creation'
down_revision = None
branch_labels = None
depends_on = None

def upgrade():
    op.create_table(
        'my_model',
        sa.Column('id', sa.Integer, primary_key=True, autoincrement=True),
        sa.Column('value', sa.String(255), nullable=False)
    )

def downgrade():
    op.drop_table('my_model')
```

The files are generated, then the migration autoruns to create the table in the database. 

Then can package the cli and publish to your private PyPI, to be able to use the auto-create functionality. E,g:
```
$ myawesomeplatform mymodel save --value "example"
$ myawesomeplatform mymodel get --id 2
$ myawesomeplatform mymodel get-all
$ myawesomeplatform mymodel delete --id 2
$ myawesomeplatform mymodel delete-all
```

HAPE enables developers to quickly initialize and structure their platform projects with minimal setup.

### Install & Upgrade Latest Version
Anyone can install HAPE Framework using `pip`.
```
$ pip install hape-framework
$ hape init --name myawesomeplatform
```
This generates a well-structured project with predefined directories for migrations, models, controllers, services, repositories, and more. The framework follows an MVC-inspired architecture where:

Updating the framework is as simple as:
```
pip install --upgrade hape-framework
```

### Using Prebuilt HAPE Services
Developers can use any services, classes, or models that are provided with the public framework in their own private platform by importing them:
```
from hape.logging import logger

from hape.config import Config

from hape.models.deployment_cost_model import DeploymentCost

from hape.services.kubernetes_service import KubernetesService

from hape.argument_parsers.config_argument_parser import ConfigArgumentParser
```
This allows developers to leverage HAPE’s built-in functionalities while maintaining the flexibility to extend and integrate with their custom platform setup.

# Author
Hazem Ataya: hazem.ataya94@gmail.com